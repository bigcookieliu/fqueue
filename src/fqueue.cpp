
// Copyright (c) 2015-2017 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of FQUEUE(https://github.com/niXman/fqueue) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <fqueue/fqueue.hpp>

#include <stdexcept>
#include <ctime>

#ifdef _WIN32
#	include <windows.h>
#else
#	include <sys/types.h>
#	include <sys/stat.h>
#	include <fcntl.h>
#	include <string.h>
#	include <unistd.h>
#	include <stdio.h>
#	include <errno.h>
#endif

#define FQUEUE_DEBUG_ENABLED 0

#if FQUEUE_DEBUG_ENABLED
#	include <iostream>
#	define FQUEUE_EXPAND_EXPR(...) \
        __VA_ARGS__
#else
#	define FQUEUE_EXPAND_EXPR(...)
#endif

namespace fqueue {

/**************************************************************************/

struct fqueue_exception: std::runtime_error {
    explicit fqueue_exception(const char *msg)
        :std::runtime_error(msg)
    {}
    explicit fqueue_exception(const std::string &msg)
        :std::runtime_error(msg)
    {}
    virtual ~fqueue_exception();

    virtual const char* what() const noexcept { return std::runtime_error::what(); }
};
fqueue_exception::~fqueue_exception() {}

/**************************************************************************/

#define _STRINGIZE(x) #x
#define STRINGIZE(x) _STRINGIZE(x)

#define FQUEUE_THROW(...) \
    throw ::fqueue::fqueue_exception(std::string("FQUEUE: " __FILE__ "(" STRINGIZE(__LINE__) "): ") + __VA_ARGS__)

#ifdef _WIN32
#define FQUEUE_THROW_IF(expr) \
    if ( (expr) ) { \
        char buf[32]; \
        ::snprintf(buf, sizeof(buf), "%u", static_cast<std::uint32_t>(::GetLastError())); \
        FQUEUE_THROW("expression \"" #expr "\" is true with GetLastError()=" + buf); \
    }
#else
#define FQUEUE_THROW_IF(expr) \
    if ( (expr) ) { \
        char buf[32]; \
        ::snprintf(buf, sizeof(buf), "%d", errno); \
        FQUEUE_THROW("expression \"" #expr "\" is true with errno=" + buf); \
    }
#endif // _WIN32

/**************************************************************************/

#ifdef _WIN32

struct file_io {
    file_io(const char *fname)
        :fd(INVALID_HANDLE_VALUE)
    {
        fd = ::CreateFileA(
             fname
            ,GENERIC_READ|GENERIC_WRITE
            ,0
            ,NULL
            ,CREATE_NEW
            ,FILE_FLAG_WRITE_THROUGH|FILE_FLAG_NO_BUFFERING
            ,NULL
        );
        FQUEUE_THROW_IF(fd == INVALID_HANDLE_VALUE);
    }
    ~file_io() {
        if ( is_open() )
            close();
    }

    bool is_open() const { return fd != INVALID_HANDLE_VALUE; }
    void close() { ::CloseHandle(fd); fd = INVALID_HANDLE_VALUE; }

    std::size_t size() {
        LARGE_INTEGER fsize;
        ::GetFileSizeEx(fd, &fsize);

        return fsize.QuadPart;
    }

    bool resize(std::size_t size) {
        if ( INVALID_SET_FILE_POINTER != ::SetFilePointer(fd, size, NULL, FILE_BEGIN) ) {
            return TRUE == ::SetEndOfFile(fd);
        }

        return false;
    }

    bool seek(std::size_t pos) {
        return INVALID_SET_FILE_POINTER != ::SetFilePointer(fd, pos, NULL, FILE_BEGIN);
    }

    bool write(const void *ptr, std::size_t /*spos*/, std::size_t size) {
        DWORD wr = 0;
        // TODO: flush
        return TRUE == ::WriteFile(fd, ptr, size, &wr, NULL) && wr == size;
    }
    bool read(void *ptr, std::size_t size) {
        DWORD rd = 0;
        return TRUE == ::ReadFile(fd, ptr, size, &rd, NULL) && rd == size;
    }

private:
    HANDLE fd;
};

#else

struct file_io {
    file_io(const char *fname)
        :fd(-1)
    {
        fd = ::open(fname, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);
        FQUEUE_THROW_IF(fd == -1);
    }
    ~file_io() {
        if ( is_open() )
            close();
    }

    bool is_open() const { return fd != -1; }
    void close() { ::close(fd); fd = -1; }

    std::size_t size() {
        struct stat st;
        ::fstat(fd, &st);

        return st.st_size;
    }

    bool resize(std::size_t size) {
        return 0 == ::ftruncate(fd, size);
    }

    bool seek(std::size_t pos) {
        return pos == static_cast<std::size_t>(::lseek(fd, pos, SEEK_SET));
    }

    bool write(const void *ptr, std::size_t spos, std::size_t size) {
        if ( size == static_cast<std::size_t>(::write(fd, ptr, size)) ) {
            return 0 == ::sync_file_range(
                 fd
                ,spos
                ,size
                ,SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER
            );
        }

        return false;
    }
    bool read(void *ptr, std::size_t size) {
        return size == static_cast<std::size_t>(::read(fd, ptr, size));
    }

private:
    int fd;
};

#endif

/**************************************************************************/

struct fqueue::impl {
    struct queue_info {
        std::uint64_t rpos;
        std::uint64_t wpos;
        std::uint64_t records;
        std::uint64_t id;
    };
    enum { size_of_queue_info = sizeof(queue_info) };
    static_assert(size_of_queue_info == sizeof(std::uint64_t)*4, "bad sizeof(queue_info)");

    impl(const char *fname, std::size_t fsize)
        :file(fname)
        ,fsize(fsize)
    {
        if ( file.size() == 0 ) {
            const queue_info qi = {
                 size_of_queue_info
                ,size_of_queue_info
                ,0
                ,0
            };

            write_info(qi);
            if ( fsize > size_of_queue_info )
                file.resize(fsize);
        }
    }

    ~impl()
    {}

    static std::uint64_t current_time() {
        ::timespec ts;
        ::clock_gettime(CLOCK_REALTIME, &ts);

        return static_cast<std::uint64_t>((ts.tv_sec*1000000000ll)+ts.tv_nsec);
    }

    std::size_t records() {
        queue_info qi;
        read_info(&qi);

        return qi.records;
    }

    std::uint64_t id() {
        queue_info qi;
        read_info(&qi);

        return qi.id;
    }

    void write_info(const queue_info &qi) {
        FQUEUE_THROW_IF(true != file.seek(0));
        FQUEUE_THROW_IF(true != file.write(&qi, 0, size_of_queue_info));
    }
    void read_info(queue_info *qi) {
        FQUEUE_THROW_IF(true != file.seek(0));
        FQUEUE_THROW_IF(true != file.read(qi, size_of_queue_info));
    }

    void reset() {
        queue_info qi;
        read_info(&qi);
        qi.rpos = qi.wpos = size_of_queue_info;
        qi.records = 0;
        write_info(qi);
    }

    void truncate() {
        reset();
        if ( fsize >= size_of_queue_info ) {
            file.resize(fsize);
        } else {
            file.resize(size_of_queue_info);
        }
    }

    std::pair<std::uint64_t, std::uint64_t>
    push(const void *ptr, std::uint32_t size) {
        queue_info qi = {0,0,0,0};
        read_info(&qi);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "push(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        const std::uint64_t wpos = qi.wpos;
        FQUEUE_THROW_IF(true != file.seek(wpos));

        const std::uint64_t id = qi.id;
        FQUEUE_THROW_IF(true != file.write(&id, qi.wpos, sizeof(id)));
        qi.wpos += sizeof(id);

        const std::uint64_t nstime = current_time();
        FQUEUE_THROW_IF(true != file.write(&nstime, qi.wpos, sizeof(nstime)));
        qi.wpos += sizeof(nstime);

        FQUEUE_THROW_IF(true != file.write(&size, qi.wpos, sizeof(size)));
        qi.wpos += sizeof(size);

        FQUEUE_THROW_IF(true != file.write(ptr, qi.wpos, size));
        qi.wpos += size;

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "buf+size=" << size+sizeof(size)
            << ", wpos=" << wpos
            << ", qi.wpos=" << qi.wpos << std::endl;
        )

        ++qi.records;
        ++qi.id;

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "push(): wr: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        write_info(qi);

        return {id, nstime};
    }

    fqueue::record read() {
        std::uint64_t id = 0;
        FQUEUE_THROW_IF(true != file.read(&id, sizeof(id)));

        std::uint64_t nstime = 0;
        FQUEUE_THROW_IF(true != file.read(&nstime, sizeof(nstime)));

        std::uint32_t block_size = 0;
        FQUEUE_THROW_IF(true != file.read(&block_size, sizeof(block_size)));

        std::unique_ptr<char[]> ptr(new char[block_size]);
        FQUEUE_THROW_IF(true != file.read(ptr.get(), block_size));

        fqueue::record rec = {
             nstime
            ,id
            ,std::move(ptr)
            ,block_size
        };

        return rec;
    }

    fqueue::record front() {
        queue_info qi;
        read_info(&qi);

        FQUEUE_THROW_IF(0 == qi.records);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "front(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        FQUEUE_THROW_IF(true != file.seek(qi.rpos));

        return read();
    }

    fqueue::record pop() {
        queue_info qi;
        read_info(&qi);

        FQUEUE_THROW_IF(0 == qi.records);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "pop(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        FQUEUE_THROW_IF(true != file.seek(qi.rpos));

        fqueue::record rec = read();

        qi.rpos +=
              sizeof(std::uint64_t) // id
            + sizeof(std::uint64_t) // nstime
            + sizeof(std::uint32_t) // block size
            + rec.size
        ;

        --qi.records;
        if ( 0 == qi.records ) {
            FQUEUE_THROW_IF(qi.rpos != qi.wpos);
            qi.rpos = qi.wpos = size_of_queue_info;
        }

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "pop(): rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records
            << (qi.rpos == qi.wpos ? " - repositioning to front!" : "") << std::endl;
        )

        write_info(qi);

        return rec;
    }

    fqueue::record first_record() { return front(); }
    fqueue::record next_record() { return read(); }

private:
    file_io file;
    const std::size_t fsize;
};

/**************************************************************************/

fqueue::fqueue(const char *fname, std::size_t fsize)
    :pimpl(new impl(fname, fsize))
{}

fqueue::~fqueue()
{}

fqueue::fqueue(fqueue &&r)
    :pimpl(std::move(r.pimpl))
{
    r.pimpl.reset();
}

fqueue& fqueue::operator=(fqueue &&r) {
    pimpl = std::move(r.pimpl);
    r.pimpl.reset();

    return *this;
}

/**************************************************************************/

std::size_t fqueue::records() const { return pimpl->records(); }
std::uint64_t fqueue::id() const { return pimpl->id(); }

bool fqueue::empty() const { return 0 == pimpl->records(); }

void fqueue::reset() { pimpl->reset(); }
void fqueue::truncate() { pimpl->truncate(); }

std::pair<std::uint64_t, std::uint64_t>
fqueue::push(const void *ptr, std::uint32_t size) { return pimpl->push(ptr, size); }
fqueue::record fqueue::front() { return pimpl->front(); }
fqueue::record fqueue::pop() { return pimpl->pop(); }

fqueue::record fqueue::first_record() { return pimpl->first_record(); }
fqueue::record fqueue::next_record() { return pimpl->next_record(); }

/**************************************************************************/

} // ns fqueue
