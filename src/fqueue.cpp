
// Copyright (c) 2015-2020 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of FQUEUE(https://github.com/niXman/fqueue) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <fqueue/fqueue.hpp>

#include <stdexcept>
#include <ctime>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

#define FQUEUE_DEBUG_ENABLED 0

#if FQUEUE_DEBUG_ENABLED
#	include <iostream>
#	define FQUEUE_EXPAND_EXPR(...) \
        __VA_ARGS__
#else
#	define FQUEUE_EXPAND_EXPR(...)
#endif

namespace fqueue {

/**************************************************************************/

struct fqueue_exception: std::runtime_error {
    explicit fqueue_exception(const char *msg)
        :std::runtime_error(msg)
    {}
    explicit fqueue_exception(const std::string &msg)
        :std::runtime_error(msg)
    {}
    virtual ~fqueue_exception();

    virtual const char* what() const noexcept { return std::runtime_error::what(); }
};
fqueue_exception::~fqueue_exception() {}

/**************************************************************************/

#define _STRINGIZE(x) #x
#define STRINGIZE(x) _STRINGIZE(x)

#define FQUEUE_THROW(...) \
    throw ::fqueue::fqueue_exception(std::string("FQUEUE: " __FILE__ "(" STRINGIZE(__LINE__) "): ") + __VA_ARGS__)

#define FQUEUE_THROW_IF(expr) \
    if ( (expr) ) { \
        char buf[32]; \
        ::snprintf(buf, sizeof(buf), "%d", errno); \
        FQUEUE_THROW("expression \"" #expr "\" is true with errno=" + buf); \
    }

/**************************************************************************/

struct file_io {
    file_io(const char *fname)
        :fd(-1)
    {
        fd = ::open(fname, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);
        FQUEUE_THROW_IF(fd == -1);
    }
    ~file_io() {
        if ( is_open() )
            close();
    }

    bool is_open() const { return fd != -1; }
    void close() { ::close(fd); fd = -1; }

    std::size_t size() {
        struct stat st;
        ::fstat(fd, &st);

        return st.st_size;
    }

    bool resize(std::size_t size) {
        return 0 == ::ftruncate(fd, size);
    }

    bool seek(std::size_t pos) {
        return pos == static_cast<std::size_t>(::lseek(fd, pos, SEEK_SET));
    }

    bool write(const void *ptr, std::size_t size) {
        if ( size == static_cast<std::size_t>(::write(fd, ptr, size)) ) {
            return 0 == ::fsync(fd);
        }

        return false;
    }
    bool read(void *ptr, std::size_t size) {
        return size == static_cast<std::size_t>(::read(fd, ptr, size));
    }

private:
    int fd;
};

/**************************************************************************/

struct fqueue::impl {
    struct queue_info {
        std::uint64_t rpos;
        std::uint64_t wpos;
        std::uint64_t records;
        std::uint64_t id;
    };
    enum { size_of_queue_info = sizeof(queue_info) };
    static_assert(size_of_queue_info == sizeof(std::uint64_t)*4, "bad sizeof(queue_info)");

    impl(const char *fname, std::size_t fsize)
        :file(fname)
        ,fsize(fsize)
    {
        if ( file.size() == 0 ) {
            const queue_info qi = {
                 size_of_queue_info
                ,size_of_queue_info
                ,0
                ,0
            };

            write_info(qi);
            if ( fsize > size_of_queue_info )
                file.resize(fsize);
        }
    }

    ~impl()
    {}

    static std::uint64_t current_time() {
        ::timespec ts;
        ::clock_gettime(CLOCK_REALTIME, &ts);

        return static_cast<std::uint64_t>((ts.tv_sec*1000000000ll)+ts.tv_nsec);
    }

    std::size_t records() {
        queue_info qi;
        read_info(&qi);

        return qi.records;
    }

    std::uint64_t id() {
        queue_info qi;
        read_info(&qi);

        return qi.id;
    }

    void write_info(const queue_info &qi) {
        FQUEUE_THROW_IF(true != file.seek(0));
        FQUEUE_THROW_IF(true != file.write(&qi, size_of_queue_info));
    }
    void read_info(queue_info *qi) const {
        FQUEUE_THROW_IF(true != file.seek(0));
        FQUEUE_THROW_IF(true != file.read(qi, size_of_queue_info));
    }

    void reset() {
        queue_info qi;
        read_info(&qi);
        qi.rpos = qi.wpos = size_of_queue_info;
        qi.records = 0;
        write_info(qi);
    }

    void truncate() {
        reset();
        if ( fsize >= size_of_queue_info ) {
            file.resize(fsize);
        } else {
            file.resize(size_of_queue_info);
        }
    }

    std::pair<std::uint64_t, std::uint64_t>
    push(const void *ptr, std::uint32_t size) {
        queue_info qi = {0,0,0,0};
        read_info(&qi);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "push(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        const std::uint64_t wpos = qi.wpos;
        FQUEUE_THROW_IF(true != file.seek(wpos));

        const std::uint64_t id = qi.id;
        FQUEUE_THROW_IF(true != file.write(&id, sizeof(id)));
        qi.wpos += sizeof(id);

        const std::uint64_t nstime = current_time();
        FQUEUE_THROW_IF(true != file.write(&nstime, sizeof(nstime)));
        qi.wpos += sizeof(nstime);

        FQUEUE_THROW_IF(true != file.write(&size, sizeof(size)));
        qi.wpos += sizeof(size);

        FQUEUE_THROW_IF(true != file.write(ptr, size));
        qi.wpos += size;

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "buf+size=" << size+sizeof(size)
            << ", wpos=" << wpos
            << ", qi.wpos=" << qi.wpos << std::endl;
        )

        ++qi.records;
        ++qi.id;

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "push(): wr: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        write_info(qi);

        return {id, nstime};
    }

    fqueue::record read() {
        std::uint64_t id = 0;
        FQUEUE_THROW_IF(true != file.read(&id, sizeof(id)));

        std::uint64_t nstime = 0;
        FQUEUE_THROW_IF(true != file.read(&nstime, sizeof(nstime)));

        std::uint32_t block_size = 0;
        FQUEUE_THROW_IF(true != file.read(&block_size, sizeof(block_size)));

        std::unique_ptr<char[]> ptr(new char[block_size]);
        FQUEUE_THROW_IF(true != file.read(ptr.get(), block_size));

        fqueue::record rec = {
             nstime
            ,id
            ,std::move(ptr)
            ,block_size
        };

        return rec;
    }

    std::uint64_t front_record_id() const {
        queue_info qi;
        read_info(&qi);

        FQUEUE_THROW_IF(0 == qi.records);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "front_record_id(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        FQUEUE_THROW_IF(true != file.seek(qi.rpos));

        std::uint64_t id = 0;
        FQUEUE_THROW_IF(true != file.read(&id, sizeof(id)));

        return id;
    }

    fqueue::record front() {
        queue_info qi;
        read_info(&qi);

        FQUEUE_THROW_IF(0 == qi.records);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "front(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        FQUEUE_THROW_IF(true != file.seek(qi.rpos));

        return read();
    }

    fqueue::record pop() {
        queue_info qi;
        read_info(&qi);

        FQUEUE_THROW_IF(0 == qi.records);

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "pop(): rd: rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records << std::endl;
        )

        FQUEUE_THROW_IF(true != file.seek(qi.rpos));

        fqueue::record rec = read();

        qi.rpos +=
              sizeof(std::uint64_t) // id
            + sizeof(std::uint64_t) // nstime
            + sizeof(std::uint32_t) // block size
            + rec.size
        ;

        --qi.records;
        if ( 0 == qi.records ) {
            FQUEUE_THROW_IF(qi.rpos != qi.wpos);
            qi.rpos = qi.wpos = size_of_queue_info;
        }

        FQUEUE_EXPAND_EXPR(
            std::cout
            << "pop(): rpos=" << qi.rpos
            << ", wpos=" << qi.wpos
            << ", records=" << qi.records
            << (qi.rpos == qi.wpos ? " - repositioning to front!" : "") << std::endl;
        )

        write_info(qi);

        return rec;
    }

    fqueue::record first_record() { return front(); }
    fqueue::record next_record() { return read(); }

private:
    mutable file_io file;
    const std::size_t fsize;
};

/**************************************************************************/

fqueue::fqueue(const char *fname, std::size_t fsize)
    :pimpl(new impl(fname, fsize))
{}

fqueue::~fqueue()
{}

fqueue::fqueue(fqueue &&r)
    :pimpl(std::move(r.pimpl))
{
    r.pimpl.reset();
}

fqueue& fqueue::operator=(fqueue &&r) {
    pimpl = std::move(r.pimpl);
    r.pimpl.reset();

    return *this;
}

/**************************************************************************/

std::size_t fqueue::records() const { return pimpl->records(); }
std::uint64_t fqueue::id() const { return pimpl->id(); }

bool fqueue::empty() const { return 0 == pimpl->records(); }

void fqueue::reset() { pimpl->reset(); }
void fqueue::truncate() { pimpl->truncate(); }

std::pair<std::uint64_t, std::uint64_t>
fqueue::push(const void *ptr, std::uint32_t size) { return pimpl->push(ptr, size); }

std::uint64_t fqueue::front_record_id() const { return pimpl->front_record_id(); }
fqueue::record fqueue::front() const { return pimpl->front(); }
fqueue::record fqueue::pop() { return pimpl->pop(); }

fqueue::record fqueue::first_record() const { return pimpl->first_record(); }
fqueue::record fqueue::next_record() { return pimpl->next_record(); }

/**************************************************************************/

} // ns fqueue
